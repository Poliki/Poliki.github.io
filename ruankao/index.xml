<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ruankaos on Poliki&#39;s Site</title>
    <link>https://example.com/ruankao/</link>
    <description>Recent content in Ruankaos on Poliki&#39;s Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language><atom:link href="https://example.com/ruankao/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title></title>
      <link>https://example.com/ruankao/uml%E5%A4%A7%E9%A2%98%E6%80%BB%E7%BB%93/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/ruankao/uml%E5%A4%A7%E9%A2%98%E6%80%BB%E7%BB%93/</guid>
      <description>UML大题  一、每年考点 2009 用例图 / 用例图+活动图
2010 用例图+类图 / 用例图+类图
2011 用例图+类图 / 用例图+类图
2012 用例图+类图 / 用例图+类图
2013 用例图+类图 / 状态图+类图
2014 通信图+类图 / 类图
2015 类图 / 用例图+类图
2016 用例图+类图 / 状态图+类图
2017 状态图+类图 / 类图
2018 用例图+类图 / 类图
2019 用例图+类图
 二、题型分析 读图和描述 给出缺少的
用例图中的-用例，关系，消息、参与者、图形符号 解释“关系”的内涵
类图中的 类名，多重度 ，解释“关系”的内涵（区别）如：聚合和组合的区别，修正类模型（修改类之间的关系）
活动图中的 判定符号 解释“关系”的内涵
使用到的设计模式的内涵：桥接，中介者，策略、组合，观察者…
数据流图 分解加工，说明画图时需要注意的问题
*出两种图合并分析的题目会简单一点，只出一种时会问设计模式+修改类的方案
 三、基本概念 关系  关联（实线三角实心）{ 聚合（实线菱形空心），组合 （实现菱形实心）}：对象之间的链接结构，链 泛化（实线三角空心）：继承，子元素共享父元素的结构和行为 依赖（虚线三角实心）：其中一个事物发生变化会影响另一个事物的语义 实现（虚线三角空心）：其中一个类指定了由另一个类保证执行的契约   四、图 1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/ruankao/%E7%AE%97%E6%B3%95%E5%A4%A7%E9%A2%98%E6%80%BB%E7%BB%93/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/ruankao/%E7%AE%97%E6%B3%95%E5%A4%A7%E9%A2%98%E6%80%BB%E7%BB%93/</guid>
      <description>算法大题  一、每年考点 2009：动态规划（最短路径） / 回溯（01背包）
2010：队列/栈（有向图的拓扑排序 ）/ 堆排序
2011：分析排序 / 回溯法
2012：贪心（最优调度）/ 贪心
2013：贪心（最优调度） / 动态规划
2014：分治 / 动态规划
2015：回溯（n皇后) / 动态规划(LCS)
2016：动态规划(电路布线-最优子结构) / KMP算法
2017：分治（假币） / 回溯 (图-哈密顿回路)
2018：动态规划 / 动态规划
2019：回溯（n皇后)
 二、题型分析 1.第一问 填三个空的代码 （1）有可能是初始化,循环条件 （2）有可能是条件判断 （3）有可能是返回值
2.第二问 问用了什么算法，时间复杂度
3.第三问 具体的数值代入题目求解
 三、时间复杂度 $$ O(1) &amp;lt; O(log_2n) &amp;lt; O(n) &amp;lt;O(nlog_2n)&amp;lt;O(n^2)&amp;lt;o(n^3)&amp;lt;O(2^n) $$
1.常数级 O(1) (1) 单个语句 如k=0;
(2) 无循环语句或复杂函数的调用
2.单层循环 O(n) 如：
void main(){ int i,j; k = 0; for(i=0;i&amp;lt;n;i++){ b[i] = 0; } } 3.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/ruankao/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%A4%A7%E9%A2%98%E6%80%BB%E7%BB%93/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/ruankao/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%A4%A7%E9%A2%98%E6%80%BB%E7%BB%93/</guid>
      <description>设计模式大题  一、每年考点 2009：桥接模式（图像浏览） / 组合模式（文件/目录树）
2010：策略模式（飞行模拟系统 ）/ 组合模式 （公司组织结构）
2011：组合模式（饭店菜单） / 状态模式（纸巾售卖机）
2012：装饰器模式（咖啡店计费）/ 抽象工厂模式（数据库兼容）
2013：原型模式（自动生成简历） / 桥接模式（图像绘制）
2014：观察者模式（实验室监控） / 命令模式（遥控器）
2015：访问模式（管理系统) / 策略模式（收银算法系统）
2016：适配器模式（不同语言显示地址） / 装饰模式（发票系统）
2017：生成器模式（出售不同套餐） / 桥接模式 （图片浏览）
2018：生成器模式（对象的构建与表示分离）/ 状态模式（航空会员）
2019：策略模式（汽车游戏)
 二、题型分析 所有问都是填代码，基于对模式的理解
 三、模式简介 1.创建型
工厂模式 定义一个创建对象的接口，但由子类决定需要实例化哪一个类
抽象工厂模式 提供接口，创建一系列相关或者相互依赖的对象，无需指定他们具体的类
原型模式 用原型实例，指定创建对象的类型，并且通过拷贝这个原型来创建新的对象
单例模式 保证一个类只有一个实例，并提供一个访问他的全局访问点
生成器（建造者）模式 将一个复杂类的表示与其构造相分离，使得相同的构建过程能够得出不同的表示
2.结构型
适配器模式 将一个类的接口转换成用户希望得到的另一种接口，使原本不相容的接口得以协同工作
桥接模式 将抽象部分与他的实现部分分离，使他们可以独立地变化
组合模式 将对象组合成树形结构以表示“整体-部分”的层次结构，使得用户对单个对象和组合对象具有一致性
装饰模式 动态地给一个对象添加一些额外的职责，提供了用子类拓展功能的一个活的替代，比派生一个子类更加灵活
外观模式 定义一个高层接口，为子系统中的一组接口提供一个一致的外观，从而简化了该子系统的使用
享元模式 提供支持大量细粒度对象共享的有效方法
代理模式 为其他对象提供一种代理以控制这个对象的访问
3.行为型
职责链模式 解除请求的发送者和接收者之间的耦合，使对个对象都有机会处理这个请求，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理他
命令模式 将请求封装为一个对象，从而可用不同的请求对客户进行参数化，将请求排队或记录请求日志，支持可撤销的操作</description>
    </item>
    
  </channel>
</rss>
